{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Computer Graphics using C language \ud83d\uddbc\ufe0f","text":"<p>This repository contains the source code for the Computer Graphics using C language course. </p>"},{"location":"#computer-graphics","title":"Computer Graphics \ud83c\udfa8","text":"<p>Computer graphics is the study of digital visual contents, and involves synthesis and manipulation of image data. It is a subfield of computer science and it is related to computer vision, computational geometry, and computational photography.</p>"},{"location":"#c-language","title":"C language \ud83d\udcdc","text":"<p>C is a general-purpose, imperative computer programming language, supporting structured programming, lexical variable scope, and recursion, while a static type system prevents many unintended operations. By design, C provides constructs that map efficiently to typical machine instructions, and therefore it has found lasting use in applications that had formerly been coded in assembly language, including operating systems, as well as various application software for computers ranging from supercomputers to embedded systems.</p>"},{"location":"Programs/2dtransformations/","title":"2 Dimensional transformations in computer graphics \ud83c\udf42","text":""},{"location":"Programs/2dtransformations/#2d-translation","title":"2D Translation","text":"<p>2D translation is the process of moving an object in a plane by a given distance in the x and y direction. The translation matrix is given by:</p> <p>\\(\\(\\begin{bmatrix} 1 &amp; 0 &amp; tx \\\\ 0 &amp; 1 &amp; ty \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\)\\) where tx and ty are the distances to be moved in the x and y direction respectively. </p> C <pre><code>    #include &lt;stdio.h&gt;\n#include &lt;graphics.h&gt;\nint main() {\nint gd = DETECT, gm;\nint x1, y1, x2, y2, tx, ty;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\nprintf(\"Enter the translation Co-ordinates : \");\nscanf(\"%d %d\", &amp;tx, &amp;ty);\nrectangle(x1, y1, x2, y2);\nrectangle(x1 + tx, y1 + ty, x2 + tx, y2 + ty);\nreturn EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"Programs/2dtransformations/#2d-scaling","title":"2D Scaling","text":"<p>2D scaling is the process of changing the size of an object in a plane by a given factor in the x and y direction. The scaling matrix is given by:</p> <p>\\(\\(\\begin{bmatrix} sx &amp; 0 &amp; 0 \\\\ 0 &amp; sy &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\)\\) where sx and sy are the scaling factors in the x and y direction respectively. </p> C <pre><code>    #include &lt;stdio.h&gt;\n#include &lt;graphics.h&gt;\nint main() {\nint gd = DETECT, gm;\nint x1, y1, x2, y2, sx, sy;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\nprintf(\"Enter the scaling Co-ordinates : \");\nscanf(\"%d %d\", &amp;sx, &amp;sy);\nrectangle(x1, y1, x2, y2);\nrectangle(x1 * sx, y1 * sy, x2 * sx, y2 * sy);\nreturn EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"Programs/2dtransformations/#2d-rotation","title":"2D Rotation","text":"<p>2D rotation is the process of rotating an object in a plane by a given angle. The rotation matrix is given by:</p> <p></p> C <pre><code>    #include &lt;stdio.h&gt;\n#include &lt;graphics.h&gt;\n#include &lt;math.h&gt;\nint main() {\nint gd = DETECT, gm;\nint x1, y1, x2, y2, x3, y3, x4, y4, angle;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\nprintf(\"Enter the rotation angle : \");\nscanf(\"%d\", &amp;angle);\nx3 = x1 * cos(angle) - y1 * sin(angle);\ny3 = x1 * sin(angle) + y1 * cos(angle);\nx4 = x2 * cos(angle) - y2 * sin(angle);\ny4 = x2 * sin(angle) + y2 * cos(angle);\nrectangle(x1, y1, x2, y2);\nrectangle(x3, y3, x4, y4);\nreturn EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"Programs/2dtransformations/#2d-reflection","title":"2D Reflection","text":"<p>2D reflection is the process of reflecting an object in a plane by a given line. The reflection matrix is given by:</p> <p></p> C <pre><code>    #include &lt;stdio.h&gt;\n#include &lt;graphics.h&gt;\nint main() {\nint gd = DETECT, gm;\nint x1, y1, x2, y2, x3, y3, x4, y4;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\nx3 = x1;\ny3 = -y1;\nx4 = x2;\ny4 = -y2;\nrectangle(x1, y1, x2, y2);\nrectangle(x3, y3, x4, y4);\nreturn EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"Programs/2dtransformations/#2d-shearing","title":"2D Shearing","text":"<p>2D shearing is the process of shearing an object in a plane by a given factor in the x and y direction. The shearing matrix is given by:</p> <p>\\(\\(\\begin{bmatrix} 1 &amp; shx &amp; 0 \\\\ shy &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\)\\) where shx and shy are the shearing factors in the x and y direction respectively.</p> <p> </p> C <pre><code>    #include &lt;stdio.h&gt;\n#include &lt;graphics.h&gt;\nint main() {\nint gd = DETECT, gm;\nint x1, y1, x2, y2, shx, shy;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\nprintf(\"Enter the shearing Co-ordinates : \");\nscanf(\"%d %d\", &amp;shx, &amp;shy);\nrectangle(x1, y1, x2, y2);\nrectangle(x1 + shx * y1, y1 + shy * x1, x2 + shx * y2, y2 + shy * x2);\nreturn EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"Programs/boundry/","title":"Boundry Fill Algorithm","text":""},{"location":"Programs/boundry/#algorithm","title":"Algorithm","text":"<p>FIlling the polygon means highlighting all the pixels which lie inside the polygon with any colour other than background.</p> <p>In this procedure, the polygon's edges are first created, and then, beginning at any place inside the polygon, we evaluate the nearby pixel to see if the boundary pixel has been reached. When boundary pixels are not reached, those pixels are highlighted and the operation is repeated until they are. </p>"},{"location":"Programs/boundry/#4-connected","title":"4 - Connected","text":"<p>Every pixel in the region may be reached by combining moves in only four directions (left, right, up, and down) in 4-connected. </p> <p><pre><code>void boundryFill(int x, int y, int f_color, int b_color) {\nif (getpixel(x, y) == b_color &amp;&amp; getpixel(x, y) != f_color) {\nputpixel(x, y, f_color);\nboundryFill(x + 1, y, f_color, b_color); // left\nboundryFill(x, y + 1, f_color, b_color); // up\nboundryFill(x - 1, y, f_color, b_color); // right\nboundryFill(x, y - 1, f_color, b_color); // down\n}\n}\n</code></pre> </p>"},{"location":"Programs/boundry/#example-1","title":"Example 1","text":"<p>The following example uses boundry fill algorithm to fill the rectangle.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;graphics.h&gt;\nvoid boundryFill(int x, int y, int f_color, int b_color) {\nif (getpixel(x, y) == b_color &amp;&amp; getpixel(x, y) != f_color) {\nputpixel(x, y, f_color);\nboundryFill(x + 1, y, f_color, b_color); // left\nboundryFill(x, y + 1, f_color, b_color); // up\nboundryFill(x - 1, y, f_color, b_color); // right\nboundryFill(x, y - 1, f_color, b_color); // down\n}\n}\nint main() {\nint gd = DETECT, gm;\nint x1, y1, x2, y2;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\nrectangle(x1, y1, x2, y2);\nboundryFill((x1 + x2) / 2, (y1 + y2) / 2, WHITE, BLACK);\nreturn EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"Programs/boundry/#output","title":"Output","text":""},{"location":"Programs/boundry/#example-2","title":"Example 2","text":"<p>The following example uses boundry fill algorithm to fill the circle.</p> <pre><code>// C Implementation for Boundary Filling Algorithm\n#include &lt;graphics.h&gt;\n// Function for 4 connected Pixels\nvoid boundaryFill4(int x, int y, int fill_color,int boundary_color)\n{\nif(getpixel(x, y) != boundary_color &amp;&amp;\ngetpixel(x, y) != fill_color)\n{\nputpixel(x, y, fill_color);\nboundaryFill4(x + 1, y, fill_color, boundary_color);\nboundaryFill4(x, y + 1, fill_color, boundary_color);\nboundaryFill4(x - 1, y, fill_color, boundary_color);\nboundaryFill4(x, y - 1, fill_color, boundary_color);\n}\n}\n//driver code\nint main()\n{\nint gd = DETECT, gm;\ninitgraph(&amp;gd, &amp;gm, \"\");\nint x = 250, y = 200, radius = 50;\n// circle function\ncircle(x, y, radius);\nboundaryFill4(x, y, 6, 15);\ndelay(10000);\ngetch();\nclosegraph();\nreturn 0;\n}\n</code></pre>"},{"location":"Programs/bresnham/","title":"DDA algorithm","text":"<p>The DDA algorithm is a simple algorithm for drawing lines. It is very fast, but it has some problems. It is not suitable for drawing thick lines, and it is not suitable for drawing lines with a slope of 1 or -1. It is also not suitable for drawing lines with a slope of 0 or infinity.</p>"},{"location":"Programs/bresnham/#algorithm","title":"Algorithm","text":"<p>The DDA algorithm is very simple. It is based on the following formula:</p> \\[ x = x_0 + t \\cdot \\Delta x \\] \\[ y = y_0 + t \\cdot \\Delta y \\] <p>where \\(t\\) is a parameter that varies from 0 to 1. The values of \\(x\\) and \\(y\\) are calculated for each value of \\(t\\). The values of \\(x\\) and \\(y\\) are rounded to the nearest integer, and the pixel at that location is set to the desired color.</p>"},{"location":"Programs/bresnham/#implementation","title":"Implementation","text":"<p>The DDA algorithm is implemented in the <code>dda</code> function in the <code>line</code> module. The function takes the following parameters:</p> <ul> <li><code>x0</code> and <code>y0</code>: The coordinates of the first point.</li> <li><code>x1</code> and <code>y1</code>: The coordinates of the second point.</li> <li><code>color</code>: The color of the line.</li> </ul> <p>The function calculates the values of \\(dx\\) (change in x) and \\(dy\\) (change in y), and then it calculates the value of <code>t</code> that will be used to calculate the values of <code>x</code> and <code>y</code>. The function then iterates from \\(t = 0\\) to \\(t = 1\\), calculating the values of <code>x</code> and <code>y</code> for each value of <code>t</code>. The values of <code>x</code> and <code>y</code> are rounded to the nearest integer, and the pixel at that location is set to the desired color.</p>"},{"location":"Programs/bresnham/#example","title":"Example","text":"<p>The following example draws a line from <code>(0, 0)</code> to <code>(100, 100)</code> using the DDA algorithm:</p> <pre><code>// DDA (Digital Differential Algorithm) algorithm\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;graphics.h&gt;\n#include&lt;math.h&gt;\nint main(){\nint gd = DETECT, gm;\nint x, y, x1, x2, y1, y2;\nint dx, dy, step, xinc, yinc, i;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\ndx = (x2 - x1);\ndy = (y2 - y1);\nif ( abs(dx) &gt;= abs(dy) )\nstep = abs(dx);\nelse\nstep = abs(dy);\nxinc = dx / step;\nyinc = dy / step;\nx = x1;\ny = y1;\nputpixel(x, y, 4);\nfor ( i = 0; i &lt; step; i++)\n{\nx += xinc;\ny += yinc;\nputpixel(x, y, 4);\n}\ngetch();\nclosegraph();\nreturn 0;\n}\n</code></pre>"},{"location":"Programs/circle/","title":"Circle Drawing Algorithm","text":"<p>```// C-program for circle drawing // using Bresenham\u2019s Algorithm // in computer-graphics</p>"},{"location":"Programs/circle/#include","title":"include","text":""},{"location":"Programs/circle/#include_1","title":"include","text":""},{"location":"Programs/circle/#include_2","title":"include  <p>// Function to put pixels // at subsequence points void drawCircle(int xc, int yc, int x, int y) {</p> <pre><code>putpixel(xc+x, yc+y, 3);\nputpixel(xc-x, yc+y, 3);\nputpixel(xc+x, yc-y, 3);\nputpixel(xc-x, yc-y, 3);\nputpixel(xc+y, yc+x, 3);\nputpixel(xc-y, yc+x, 3);\nputpixel(xc+y, yc-x, 3);\nputpixel(xc-y, yc-x, 3);\n</code></pre> <p>}</p> <p>// Function for circle-generation // using Bresenham's algorithm void circleBres(int xc, int yc, int r) {     int x = 0, y = r;     int d = 3 - 2 * r;     drawCircle(xc, yc, x, y);     while (y &gt;= x)     {         // for each pixel we will         // draw all eight pixels</p> <pre><code>    x++;\n\n    // check for decision parameter\n    // and correspondingly\n    // update d, x, y\n    if (d &gt; 0)\n    {\n        y--;\n        d = d + 4 * (x - y) + 10;\n    }\n    else\n        d = d + 4 * x + 6;\n    drawCircle(xc, yc, x, y);\n    delay(100);\n}\n</code></pre> <p>}</p> <p>// Driver code int main() {     int xc = 100, yc = 100, r = 80;     int gd = DETECT, gm;     initgraph(&amp;gd, &amp;gm, \"\"); // initialize graph     outtextxy(70,80,\"Bresenham Circle\");     circleBres(xc, yc, r); // function call     delay(5000);     return 0; } ```</p>","text":""},{"location":"Programs/dda/","title":"DDA algorithm","text":"<p>The DDA algorithm is a simple algorithm for drawing lines. It is very fast, but it has some problems. It is not suitable for drawing thick lines, and it is not suitable for drawing lines with a slope of 1 or -1. It is also not suitable for drawing lines with a slope of 0 or infinity.</p>"},{"location":"Programs/dda/#algorithm","title":"Algorithm","text":"<p>The DDA algorithm is very simple. It is based on the following formula:</p> \\[ x = x_0 + t \\cdot \\Delta x \\] \\[ y = y_0 + t \\cdot \\Delta y \\] <p>where \\(t\\) is a parameter that varies from 0 to 1. The values of \\(x\\) and \\(y\\) are calculated for each value of \\(t\\). The values of \\(x\\) and \\(y\\) are rounded to the nearest integer, and the pixel at that location is set to the desired color.</p>"},{"location":"Programs/dda/#implementation","title":"Implementation","text":"<p>The DDA algorithm is implemented in the <code>dda</code> function in the <code>line</code> module. The function takes the following parameters:</p> <ul> <li><code>x0</code> and <code>y0</code>: The coordinates of the first point.</li> <li><code>x1</code> and <code>y1</code>: The coordinates of the second point.</li> <li><code>color</code>: The color of the line.</li> </ul> <p>The function calculates the values of \\(dx\\) (change in x) and \\(dy\\) (change in y), and then it calculates the value of <code>t</code> that will be used to calculate the values of <code>x</code> and <code>y</code>. The function then iterates from \\(t = 0\\) to \\(t = 1\\), calculating the values of <code>x</code> and <code>y</code> for each value of <code>t</code>. The values of <code>x</code> and <code>y</code> are rounded to the nearest integer, and the pixel at that location is set to the desired color.</p>"},{"location":"Programs/dda/#example","title":"Example","text":"<p>The following example draws a line from <code>(0, 0)</code> to <code>(100, 100)</code> using the DDA algorithm:</p> <pre><code>// DDA (Digital Differential Algorithm) algorithm\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;graphics.h&gt;\n#include&lt;math.h&gt;\nint main(){\nint gd = DETECT, gm;\nint x, y, x1, x2, y1, y2;\nint dx, dy, step, xinc, yinc, i;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\ndx = (x2 - x1);\ndy = (y2 - y1);\nif ( abs(dx) &gt;= abs(dy) )\nstep = abs(dx);\nelse\nstep = abs(dy);\nxinc = dx / step;\nyinc = dy / step;\nx = x1;\ny = y1;\nputpixel(x, y, 4);\nfor ( i = 0; i &lt; step; i++)\n{\nx += xinc;\ny += yinc;\nputpixel(x, y, 4);\n}\ngetch();\nclosegraph();\nreturn 0;\n}\n</code></pre>"},{"location":"Programs/flood/","title":"Boundry Fill Algorithm","text":""},{"location":"Programs/flood/#algorithm","title":"Algorithm","text":"<p>FIlling the polygon means highlighting all the pixels which lie inside the polygon with any colour other than background.</p> <p>In this procedure, the polygon's edges are first created, and then, beginning at any place inside the polygon, we evaluate the nearby pixel to see if the boundary pixel has been reached. When boundary pixels are not reached, those pixels are highlighted and the operation is repeated until they are. </p>"},{"location":"Programs/flood/#4-connected","title":"4 - Connected","text":"<p>Every pixel in the region may be reached by combining moves in only four directions (left, right, up, and down) in 4-connected. </p> <pre><code>void boundryFill(int x, int y, int f_color, int b_color) {\nif (getpixel(x, y) != b_color &amp;&amp; getpixel(x, y) != f_color) {\nputpixel(x, y, f_color);\nboundryFill(x + 1, y, f_color, b_color); // left\nboundryFill(x, y + 1, f_color, b_color); // up\nboundryFill(x - 1, y, f_color, b_color); // right\nboundryFill(x, y - 1, f_color, b_color); // down\n}\n}\n</code></pre>"},{"location":"Programs/flood/#example","title":"Example","text":"<p>The following example uses boundry fill algorithm to fill the rectangle.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;graphics.h&gt;\nvoid boundryFill(int x, int y, int f_color, int b_color) {\nif (getpixel(x, y) != b_color &amp;&amp; getpixel(x, y) != f_color) {\nputpixel(x, y, f_color);\nboundryFill(x + 1, y, f_color, b_color); // left\nboundryFill(x, y + 1, f_color, b_color); // up\nboundryFill(x - 1, y, f_color, b_color); // right\nboundryFill(x, y - 1, f_color, b_color); // down\n}\n}\nint main() {\nint gd = DETECT, gm;\nint x1, y1, x2, y2;\ninitgraph(&amp;gd, &amp;gm, \"C:\\\\Program Files (x86)\\\\Colorado\\\\cs1300\\\\bgi\");\nprintf(\"Enter the staring Co-ordinates : \");\nscanf(\"%d %d\", &amp;x1, &amp;y1);\nprintf(\"Enter the end Co-ordinates : \");\nscanf(\"%d %d\", &amp;x2, &amp;y2);\nrectangle(x1, y1, x2, y2);\nboundryFill((x1 + x2) / 2, (y1 + y2) / 2, WHITE, BLACK);\nreturn EXIT_SUCCESS;\n}\n</code></pre>"}]}